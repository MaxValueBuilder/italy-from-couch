import { Tour, WeeklyRecurrencePattern, OneTimeSlot, TimeSlot } from "@/lib/data/tours"
import { TourSlot } from "@/lib/data/bookings"
import { getCityTimezone, addDuration } from "./timezone"

/**
 * Generate TourSlot instances from a tour's recurrence pattern
 * @param tour - The tour with recurrence pattern
 * @param startDate - Start date for generation
 * @param endDate - End date for generation
 * @returns Array of generated TourSlot instances
 */
export function generateSlotsFromWeeklyPattern(
  tour: Tour,
  startDate: Date,
  endDate: Date
): TourSlot[] {
  if (!tour.recurrencePattern || tour.recurrenceType !== "weekly") {
    return []
  }

  const pattern = tour.recurrencePattern
  const timezone = tour.timezone || getCityTimezone(tour.city)
  const maxParticipants = tour.maxParticipants || 50
  const slots: TourSlot[] = []

  // Iterate through each day in the date range
  const currentDate = new Date(startDate)
  while (currentDate <= endDate) {
    const dayOfWeek = currentDate.getDay() // 0 = Sunday, 1 = Monday, etc.

    // Check if this day matches the pattern
    if (pattern.daysOfWeek.includes(dayOfWeek)) {
      // Generate slots for each time slot on this day
      for (const timeSlot of pattern.timeSlots) {
        const [startHour, startMinute] = timeSlot.startTime.split(":").map(Number)
        const [endHour, endMinute] = timeSlot.endTime.split(":").map(Number)

        const slotStart = new Date(currentDate)
        slotStart.setHours(startHour, startMinute, 0, 0)

        const slotEnd = new Date(currentDate)
        slotEnd.setHours(endHour, endMinute, 0, 0)

        // Ensure end time is after start time (handle next day)
        if (slotEnd <= slotStart) {
          slotEnd.setDate(slotEnd.getDate() + 1)
        }

        // Get guideId from tour (could be guide name or guideId)
        // For now, we'll need to look it up or pass it separately
        slots.push({
          _id: "", // Will be generated by database
          tourId: tour._id,
          guideId: (tour as any).guideId || "", // Will be set from tour when available
          startTime: slotStart,
          endTime: slotEnd,
          timezone,
          maxParticipants,
          bookedCount: 0,
          isAvailable: true,
          createdAt: new Date(),
          updatedAt: new Date(),
        })
      }
    }

    // Move to next day
    currentDate.setDate(currentDate.getDate() + 1)
  }

  return slots
}

/**
 * Generate TourSlot instances from one-time slots
 * @param tour - The tour with one-time slots
 * @param startDate - Start date for filtering (optional)
 * @param endDate - End date for filtering (optional)
 * @returns Array of generated TourSlot instances
 */
export function generateSlotsFromOneTime(
  tour: Tour,
  startDate?: Date,
  endDate?: Date
): TourSlot[] {
  if (!tour.oneTimeSlots || tour.recurrenceType !== "none") {
    return []
  }

  const timezone = tour.timezone || getCityTimezone(tour.city)
  const maxParticipants = tour.maxParticipants || 50
  const slots: TourSlot[] = []

  for (const oneTimeSlot of tour.oneTimeSlots) {
    const slotDate = new Date(oneTimeSlot.date)

    // Filter by date range if provided
    if (startDate && slotDate < startDate) continue
    if (endDate && slotDate > endDate) continue

    // Generate slots for each time slot on this date
    for (const timeSlot of oneTimeSlot.timeSlots) {
      const [startHour, startMinute] = timeSlot.startTime.split(":").map(Number)
      const [endHour, endMinute] = timeSlot.endTime.split(":").map(Number)

      const slotStart = new Date(slotDate)
      slotStart.setHours(startHour, startMinute, 0, 0)

      const slotEnd = new Date(slotDate)
      slotEnd.setHours(endHour, endMinute, 0, 0)

      // Ensure end time is after start time (handle next day)
      if (slotEnd <= slotStart) {
        slotEnd.setDate(slotEnd.getDate() + 1)
      }

      slots.push({
        _id: "", // Will be generated by database
        tourId: tour._id,
        guideId: "", // Should be set from tour.guide
        startTime: slotStart,
        endTime: slotEnd,
        timezone,
        maxParticipants,
        bookedCount: 0,
        isAvailable: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      })
    }
  }

  return slots
}

/**
 * Generate all TourSlot instances for a tour based on its configuration
 * @param tour - The tour
 * @param startDate - Start date for generation
 * @param endDate - End date for generation
 * @returns Array of generated TourSlot instances
 */
export function generateTourSlots(
  tour: Tour,
  startDate: Date,
  endDate: Date
): TourSlot[] {
  if (tour.recurrenceType === "weekly" && tour.recurrencePattern) {
    return generateSlotsFromWeeklyPattern(tour, startDate, endDate)
  } else if (tour.recurrenceType === "none" && tour.oneTimeSlots) {
    return generateSlotsFromOneTime(tour, startDate, endDate)
  }

  return []
}
